# OpencV

## MAT容器

图像在OpenCV中的存储形式

### MAT类

图像以离散数字的形式存储在计算机中。

![](./assets/2023-10-17-22-07-40.png)

MAT类相当于一种数据类型，该类中存储矩阵形式的数据，可以是多维的，比如2x3x3。

其数据结构包含矩阵头，跟数据部分

![](./assets/2023-10-17-22-09-17.png)

### 矩阵头

矩阵头包含MAT类的尺寸，行数，列数，数据类型，通道数，引用次数。

假设数据的大小为 a x b x c

尺寸为axb，行数为a，列数为b，通道数为c。

假设在程序中定义了两个MAT a和b，a和b在内存中共用的是同一份数据img。当内存中的img被删除后，a和b引用的就是一个空的数据。此时用引用次数表示该数据被引用了多少次，避免在删除b的时候导致a引用的数据为空。

### 数据

数据可以是图像，也可以是离散的矩阵，比如相机参数，或者神经网络的权值参数。

官方给出的MAT可以存储以下几种数据类型：

![](./assets/2023-10-17-22-19-39.png)

cv::Mat_<_Tp>: 用户自定义MAT中存储的数据类型，其余的就为途中所写的那些数据类型。

但是不同数据类型的位数可能会根据计算机的更新发生变化，比如单片机，ARM处理器和x86的计算机中同一种数据类型的位数不一样。为了避免这个问题，Opencv进行了一个强制的对应，只指明对应数据类型有多少位。

如图所示，数字表示数据的位数，U：unsigned，S：signed，F：float

![](./assets/2023-10-17-22-22-31.png)

### MAT类的创建和赋值

#### 利用矩阵的宽、高和类型参数创建Mat类

```cpp
cv::Mat::Mat(
    int rows,   // 构造矩阵的行数
    int cols,   // 构造矩阵的列数
    int type    // 构造矩阵的数据类型
)
```

数据类型即为之前讲过的那些数据类型，除了CV_8UC1、CV_64FC4等1到4通道以外，还提供了更多通道的参数，通过CV_8UC(n)中的n来构建多通道矩阵，其中最大可取到512。不用C时默认为1通道。

例如：
```cpp
// 创建3x3 3通道的矩阵
Mat(3, 3, CV_8UC(3))
```

##### 利用矩阵Size()结构和数据类型参数创建Mat类

```cpp
cv::Mat::Mat(
    Size size,  // 2D数组变量尺寸，通过Size(cols, rows)赋值
    int type    // 数据类型
)
```

例如：
```cpp
Mat(Size(3, 3), CV_8UC(2))
```

#### 利用已有的Mat类创建新的Mat类

```cpp
cv::Mat::Mat(
    const Mat & m,          // 已创建的Mat类矩阵数据
    const Range & rowRange, // 在已有矩阵中需要截取的行数范围，例如2到5行为 Range(2, 5)
    const Range & colRange  // 在已有矩阵中需要截取的列数范围，例如2到5列为 Range(2, 5)，当不输入任何范围时，表示所有列都会被截取
)
```

需要注意的是，行和列是从0开始计数的，Range(2, 5)截取的其实是第三行到第六行。

#### 赋值

##### 在创建时赋值

在后面加上参数

```cpp
cv::Mat::Mat(
    int rows,           // 矩阵行数
    int cols,           // 矩阵列数
    int type,           // 数据类型
    const Scalar & s    // 给矩阵中每个像素赋值的参数变量， 例如Scalar(0, 0, 255)
)
```

例如

```cpp
Mat f(3, 3, CV_8U, Scalar(1))
```

需要注意的是，参数中可以输入任意位数据，例如五位 Scalar(0, 0, 0, 0, 0)，此时假设定义的Mat只有三个通道，赋值过程是依次向三个通道中赋值，若Scalar中的位数大于通道数，则多余的数据会被丢弃。

类方法中定义了一些能够直接实现的矩阵类型

##### 类方法赋值

1. **eye**：单位阵
2. **diag**：对角矩阵
3. **ones**：元素权威1的矩阵
4. **zeros**：元素全为0的矩阵

对角阵要求输入量位一个已有的矩阵

##### 枚举法赋值

```cpp
// 先定义Mat对象，然后声明存储的数据类型，及Mat类的尺寸，最后将数据输入

cv::Mat a = (cv::Mat_<int>(3, 3) << 1, 2, 3, 4, 5, 6, 7, 8 ,9);

cv::Mat b = (cv::Mat_<double>(2, 3) << 1.0, 2.0, 3.0, 4.0 ,5.1, 6.2);
```

在之前类方法赋值方式中，无法保证每一位是任意的，此方法中的每一位都是指定的。

此时写的类型不是Opencv自己定义的，而是C中常见的那些数据类型。

### 代码片段

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main()
{
	Mat a(3, 3, CV_8UC1);
	Mat b(Size(4, 4), CV_8UC1);
	Mat c0(5, 5, CV_8UC1, Scalar(4, 5, 6));
	Mat c1(5, 5, CV_8UC2, Scalar(4, 5, 6));
	Mat c2(5, 5, CV_8UC3, Scalar(4, 5, 6));
	Mat d = (cv::Mat_<int>(1, 5) << 1, 2, 3, 4, 5);
	Mat e = Mat::diag(d);
	Mat f = Mat(e, Range(2, 4), Range(2, 4));

    cout << c0 << endl;
    cout << c1 << endl;
    cout << c2 << endl;
}
```

